---
title: "CFB Model Data Prep"
author: "_____"
date: "2024-09-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages
```{r}
# packages
library(tidyverse)
library(cfbfastR)
library(ggplot2)
library(RcppRoll)
library(zoo)
```
```{r}
#detach("package:cfbfastR", unload = TRUE)
```


```{r}
# You can install using the pacman package using the following code:
# if (!requireNamespace('pacman', quietly = TRUE)){
#   install.packages('pacman')
# }
# pacman::p_load_current_gh("sportsdataverse/cfbfastR", dependencies = TRUE, update = TRUE)
```




## Load Data
```{r}

### IDENTIFY CURRENT SEASON ###

current_season = 2024
current_week = 7




### LOAD IN GBG Data ###



# function to load
load_gi_data_func = function(year_start, year_end) {
  
  # loop to load data
  for (szn in c(year_start:year_end)){
    # this one creates the df for the first year in the loop
    if (szn == year_start){
      full_df = cfbd_game_info(year = szn, season_type = "regular")
      df = cfbd_game_info(year = szn, season_type = "postseason")
      full_df = bind_rows(full_df, df)
    # this one binds other dfs to full_df
    } else{
        df = cfbd_game_info(year = szn, season_type = "regular")
        full_df = bind_rows(full_df, df)
        df = cfbd_game_info(year = szn, season_type = "postseason")
        full_df = bind_rows(full_df, df)
  }
  }
  # return one df with all years of data
  return(full_df)
}




# load in gbg data
game_info_orig = load_gi_data_func(current_season, current_season) # original df
game_info = game_info_orig %>% 
  # change weeks for postseason
  mutate(week = ifelse(season_type == "regular", week, ifelse(
         str_detect(notes, "Quarterfinal"), 21, ifelse(
         str_detect(notes, "Semifinal") | str_detect(notes, "SEMIFINAL"), 22, ifelse(
         str_detect(notes, "National Championship") | str_detect(notes, "NATIONAL CHAMPIONSHIP"), 23, 20
         )
         )
  ))) %>% 
  mutate(week = ifelse(game_id == 400852733, 22, ifelse(
         game_id == 400852732, 22, ifelse(
         game_id == 400876108, 22, ifelse(
         game_id == 400876107, 22, week
         )
         )
  ))) %>% 
  mutate(week = ifelse(season_type == "postseason" & is.na(week), 20, week)) %>% 
  rename(home_division = home_classification,
         away_division = away_classification) %>% 
  filter(week <= current_week)


# reference df for weeks
week_id = game_info %>% select(game_id, week) %>% rename(new_week = week)











### LOAD IN PBP DATA ###


# load cfb pbp data 
cfb_data_reg_orig = load_cfb_pbp(seasons = c(current_season:current_season)) 
cfb_data_reg = cfb_data_reg_orig



# create postseason data function
load_post_data_func = function(year_start, year_end) {
  
  # loop to load data
  for (szn in c(year_start:year_end)){
    # this one creates the df for the first year in the loop
    if (szn == year_start){
      full_df = cfbd_pbp_data(year = szn, season_type = "postseason", epa_wpa = TRUE)
    # this one binds other dfs to full_df
    } else{
        df = cfbd_pbp_data(year = szn, season_type = "postseason", epa_wpa = TRUE)
        full_df = rbind(full_df, df)
  }
  }
  # return one df with all years of data
  return(full_df)
}



### bug in cfbfastr package for postseason api call, ignore for now

# if (current_week>18){
# 
#   # load in postseason pbp data
#   cfb_data_post_orig = load_post_data_func(current_season, current_season)
#   cfb_data_post = cfb_data_post_orig %>% 
#     rename(week = wk,
#            year = season)
#   cfb_data_post = left_join(cfb_data_post, week_id, by = "game_id")
#   cfb_data_post$week = cfb_data_post$new_week
#   cfb_data_post = cfb_data_post %>% select(-c(new_week))
#   
#   
#   
#   # join regular and postseason data
#   common_cols <- intersect(names(cfb_data_reg_orig), names(cfb_data_post))
#   cfb_data_post <- cfb_data_post %>% select(all_of(common_cols))
#   cfb_data_post$id_play = as.integer(cfb_data_post$id_play)
#   cfb_data_post$half = as.integer(cfb_data_post$half)
#   cfb_data_post$down_end = as.integer(cfb_data_post$down_end)
#   cfb_data_post$ppa = as.integer(cfb_data_post$ppa)
#   cfb_data_post$id_drive = as.integer(cfb_data_post$id_drive)
#   cfb_data <- bind_rows(cfb_data_reg, cfb_data_post)
#   
# } else{
#   cfb_data = cfb_data_reg
# }

cfb_data = cfb_data_reg


# filter out meaningless rows, make team names the same, mutate play_count to make later calcs easier
cfb_data = cfb_data %>% 
  filter(!play_type %in% c('End Period', 'End of Half', 'Timeout')) %>%
  mutate(pos_team = recode(pos_team, 'Appalachian State' = 'App State',
                            'Connecticut' = 'UConn',
                            'Sam Houston State' = 'Sam Houston',
                            'Louisiana Monroe' = 'UL Monroe')) %>% 
  mutate(def_pos_team = recode(def_pos_team, 'Appalachian State' = 'App State',
                            'Connecticut' = 'UConn',
                            'Sam Houston State' = 'Sam Houston',
                            'Louisiana Monroe' = 'UL Monroe')) %>% 
  mutate(play_count = 1) %>% 
  filter(week <= current_week-1)




# add row to calc prev stats for next week
# need to add to pbp or else won't create a col for that week

new_rows = cfb_data %>% 
  filter(year == current_season, 
         week == current_week - 1 | week == current_week - 2 | week == current_week - 3) %>% 
  mutate(week = current_week) 
new_rows[,c(3:7,10:58,60:185,187,189:330)] = 0
cfb_data = rbind(cfb_data, new_rows)









### LOAD IN BETTING DATA ###


# function to load in data
load_bet_data_func = function(year_start, year_end, joining_data){
  
      full_df = cfbd_betting_lines(year = 2015, away_team = "Notre Dame")
      full_df = full_df[0,]
      full_df$over_under = as.numeric(full_df$over_under)
      full_df$spread_open = as.numeric(full_df$spread_open)
      full_df$over_under_open = as.numeric(full_df$over_under_open)
      full_df$spread = as.numeric(full_df$spread)
      
      game_info_fbs = joining_data %>% 
        filter(away_division == "fbs" | home_division == "fbs")
      
      for (szn in c(year_start:year_end)){
        
        print(szn)
        
        if (szn <= 2018){
        
            team_list_df = game_info_fbs %>% 
              filter(season == szn)
            team_list = unique(game_info_fbs$away_team)
            
            for (tm in team_list){
              df = cfbd_betting_lines(year = szn, season_type = "regular", away_team = tm)
              df$over_under = as.numeric(df$over_under)
              df$spread_open = as.numeric(df$spread_open)
              df$over_under_open = as.numeric(df$over_under_open)
              df$spread = as.numeric(df$spread)
              full_df = bind_rows(full_df, df)
            
            }
            
            for (tm in team_list){
              df = cfbd_betting_lines(year = szn, season_type = "postseason", away_team = tm)
              df$over_under = as.numeric(df$over_under)
              df$spread_open = as.numeric(df$spread_open)
              df$over_under_open = as.numeric(df$over_under_open)
              df$spread = as.numeric(df$spread)
              full_df = bind_rows(full_df, df)
            
            }
        } 
        else{
          
            df = cfbd_betting_lines(year = szn, season_type = "regular")
            df$over_under = as.numeric(df$over_under)
            df$spread_open = as.numeric(df$spread_open)
            df$over_under_open = as.numeric(df$over_under_open)
            df$spread = as.numeric(df$spread)
            full_df = bind_rows(full_df, df)
            
            if (current_week>19){
            
              df = cfbd_betting_lines(year = szn, season_type = "postseason")
              df$over_under = as.numeric(df$over_under)
              df$spread_open = as.numeric(df$spread_open)
              df$over_under_open = as.numeric(df$over_under_open)
              df$spread = as.numeric(df$spread)
              full_df = bind_rows(full_df, df)
            }
            
            
        }
        
  
      }
      
      return(full_df)
  
  
}


# load in betting data
betting_lines_orig = load_bet_data_func(current_season, current_season, game_info)
betting_lines = betting_lines_orig %>% filter(week<=current_week)











### LOAD IN TALENT DATA ###

# function to load weather data
load_talent_data_func = function(year_start, year_end) {
  
  # loop to load data
  for (szn in c(year_start:year_end)){
    # this one creates the df for the first year in the loop
    if (szn == year_start){
      full_df = cfbd_team_talent(year = szn)
    # this one binds other dfs to full_df
    } else{
        df = cfbd_team_talent(year = szn)
        full_df = bind_rows(full_df, df)
        }
  }
  # return one df with all years of data
  return(full_df)
}



# team talent data load
talent_data_orig = load_talent_data_func(current_season, current_season)










### LOAD IN WEATHER DATA



# # function to load weather data
# load_weather_data_func = function(year_start, year_end) {
#   
#   # loop to load data
#   for (szn in c(year_start:year_end)){
#     # this one creates the df for the first year in the loop
#     if (szn == year_start){
#       full_df = cfbd_game_weather(year = szn, season_type = "regular")
#       df = cfbd_game_weather(year = szn, season_type = "postseason")
#       full_df = bind_rows(full_df, df)
#     # this one binds other dfs to full_df
#     } else{
#         df = cfbd_game_weather(year = szn, season_type = "regular")
#         full_df = bind_rows(full_df, df)
#         df = cfbd_game_weather(year = szn, season_type = "postseason")
#         full_df = bind_rows(full_df, df)
#         }
#   }
#   # return one df with all years of data
#   return(full_df)
# }
# 
# # weather data load
# weather_data_orig = load_weather_data_func(current_season, current_season)









### LOAD IN RANKING DATA ###


# function to load ranking data
load_ranking_data_func = function(year_start, year_end) {
  
  # loop to load data
  for (szn in c(year_start:year_end)){
    # this one creates the df for the first year in the loop
    if (szn == year_start){
      full_df = cfbd_rankings(year = szn, season_type = "regular")
      df = cfbd_rankings(year = szn, season_type = "postseason")
      full_df = bind_rows(full_df, df)
    # this one binds other dfs to full_df
    } else{
        df = cfbd_rankings(year = szn, season_type = "regular")
        full_df = bind_rows(full_df, df)
        df = cfbd_rankings(year = szn, season_type = "postseason")
        full_df = bind_rows(full_df, df)
  }
  }
  # return one df with all years of data
  return(full_df)
}


# load ranking data
ranking_data_orig = load_ranking_data_func(current_season,current_season) %>% filter(week<=current_week)







# not including stats data for now



### LOAD IN STATS DATA ###



# weeks_in_seasons = game_info_orig %>% 
#   filter(completed, season_type == "regular", away_classification == "fbs" | away_classification == "fbs") %>%
#   group_by(season) %>% 
#   summarize(max_week = max(week)) %>% 
#   mutate(max_week = ifelse(max_week>15, 15, max_week))


# load_stats_data_func = function(start_yr, end_yr){
# 
#       for (yr in c(start_yr:end_yr)){
#         
#         print(yr)
#         
#         weeks_this_reg_szn = (weeks_in_seasons %>% filter(season == yr))[[2]]
#         
#       
#         for (end_wk in c(1:weeks_this_reg_szn)){
#           
#           print(end_wk)
#           
#             for (range in c(1,3,20)){
#               
#               
#                   start_wk = ifelse(end_wk + 1 - range < 1, 1, end_wk + 1 - range)
#       
#                   data_pulled = cfbd_stats_season_advanced(
#                     yr,
#                     excl_garbage_time = TRUE,
#                     start_week = start_wk,
#                     end_week = end_wk
#                   )
#                   
#                   data_mut = data_pulled %>% 
#                     select(-c(conference))
#                   
#                   
#                   colnames(data_mut)[3:length(colnames(data_mut))] <- paste0("rol_", colnames(data_mut)[3:length(colnames(data_mut))], "_l", range)
#                   
#                   
#                   
#                   if(range == 1){
#                     
#                     data_mut = data_mut %>% mutate(end_week = end_wk)
#                     week_df = data_mut
#                     
#                   } else{
#                     
#                     data_mut = data_mut %>% select(-c(season))
#                     week_df = left_join(week_df, data_mut, by = "team")
#                     
#                   }
#          
#                   
#             }
#           
#             
#             if(end_wk == 1){
#               year_df = week_df
#             } else{
#               year_df = bind_rows(week_df, year_df)
#             }
#           
#           
#           
#         }
#         
#         
#         if(yr == start_yr){
#           final_df = year_df
#         } else{
#           final_df = bind_rows(year_df, final_df)
#         }
#         
#         
#       }
#       
#    return(final_df)
# 
# }
# 
# 
# 
# 
# stat_data_orig = load_stats_data_func(current_season, current_season)
# 
# 
# 
# 
# stat_data = stat_data_orig %>% 
#   mutate(join_wk = end_week + 1) %>% 
#   select(-c(end_week))

# stat_data = stat_data %>% 
#   select(-c(grep("rol_off_plays", names(stat_data)),
#             grep("rol_def_plays", names(stat_data)),
#             grep("rol_off_drives", names(stat_data)),
#             grep("rol_def_drives", names(stat_data)),
#             grep("line_yds_total", names(stat_data)),
#             grep("lvl_yds_total", names(stat_data)),
#             grep("field_yds_total", names(stat_data)),
#             grep("total_opportunities", names(stat_data)),
#             grep("total_ppa", names(stat_data))))



# data_pulled = cfbd_stats_season_advanced(
#                     2024,
#                     excl_garbage_time = TRUE,
#                     start_week = 16,
#                     end_week = 16
#                   )


```



## Rolling Per Game Function
```{r}
# Function to compile rolling metric variables per game
# meant for metrics that should be calculated at per game level


### FUNCTION ARGS EXPLAINED
# metrics: input list of desired metrics as they appear in cfb_data columns, e.g. c(EPA, wpa, ...)
# n_games: how many games for rolling sum to go back?, e.g. 5
# input_data: what data are we using (should always be cfb_data or filtered version), e.g. cfb_data



# Define function
rolling_pg_compiler = function(metrics, n_games, input_data){
  
  
  
  # Offensive Metrics
  
  
  
  # create list to store created dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', i, "_pg")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i))) %>% # sum the stat
      arrange(pos_team, year, week) %>% # sort by each levels, get weeks in order
      group_by(pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # make another lag column, will be 1 if it is not NA and 0 if it is NA
      # now, we have the previous week's metric (if played) and whether a game was played last week
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_game = ifelse(is.na(lag(tot_stat)),0,
                               1)) %>% 
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_game col, telling us how many games played over period
      # standardizes it in case a team only played two games before this season but it's a 3 game roll mean
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum,
                                           partial = TRUE, align = 'right') /
                                rollapplyr(lag_game, width = n_games, FUN = sum,
                                           partial = TRUE, align = 'right')) %>%
      
      select(-c(tot_stat, lag_stat, lag_game)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  off_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(off_df)))) {
    colnames(off_df)[i] = gsub(".*\\.", "", colnames(off_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    off_df = left_join(off_df, joining_df, by = c('pos_team', 'year', 'week'))
  }

  # rename pos_team so we can later merge with def stats
  off_df = off_df %>% 
    rename(team = pos_team)
  
  # add _off to cols for when we merge this to def
  colnames(off_df)[4:length(colnames(off_df))] = paste0(colnames(off_df)[4:length(colnames(off_df))], "_off_l", n_games)
  
  
  
  
  
  
  
  # Defensive metrics 
  
  
  
  # create list to store created defensive dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', i, "_pg")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(def_pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i))) %>% # sum the stat
      arrange(def_pos_team, year, week) %>% # sort by each level
      group_by(def_pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # make another lag column, will be 1 if it is not NA and 0 if it is NA
      # now, we have the previous week's metric (if played) and whether a game was played last week
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_game = ifelse(is.na(lag(tot_stat)),0,
                               1)) %>% 
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_game col, telling us how many games played over period
      # standardizes it in case a team only played two games before this season but it's a 3 game roll mean
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right') /
                                rollapplyr(lag_game, width = n_games, FUN = sum,
                                           partial = TRUE, align = 'right')) %>%
      
      select(-c(tot_stat, lag_stat, lag_game)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  def_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(def_df)))) {
    colnames(def_df)[i] = gsub(".*\\.", "", colnames(def_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    def_df = left_join(def_df, joining_df, by = c('def_pos_team', 'year', 'week'))
  }
   
  # change def_pos_team for when we merge to off metrics
  def_df = def_df %>% 
    rename(team = def_pos_team)
  
  # add _def to cols so we differentiate from off metrics when merged
  colnames(def_df)[4:length(colnames(def_df))] = paste0(colnames(def_df)[4:length(colnames(def_df))], "_def_l", n_games)
  
  
  
  
  
  # Join Off and Def Metric dfs
  
  # left join
  full_df = left_join(off_df, def_df, by = c("team", "year", "week"))
  
  # rename game_id col, got messed up, and rename year to season for later merging
  colnames(full_df)[2] = "season"
  
  # return value is the one df with all rolling sums
  return(full_df)
  
}



```



## Rolling Per Play Function
```{r}
# Function to compile rolling metric variables per play
# meant for metrics that should be aggregated at per play level


### FUNCTION ARGS EXPLAINED
# metrics: input list of desired metrics as they appear in cfb_data columns, e.g. c(EPA, wpa, ...)
# n_games: how many games for rolling sum to go back?, e.g. 5
# input_data: what data are we using (should always be cfb_data or filtered version), e.g. cfb_data



# Define function
rolling_pp_compiler = function(metrics, n_games, input_data){
  
  
  
  # Offensive Metrics
  
  
  
  # create list to store created dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', i, "_pp")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i)), # sum the stat
                tot_plays = sum(play_count)) %>% # sum the play count to calc per play later
      arrange(pos_team, year, week) %>% # sort by each level
      group_by(pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # if the previous row's plays is NA (haven't played a game yet), then make it 0 for the sum calc
      # now, we have the previous week's metric and plays
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_plays = ifelse(is.na(lag(tot_plays)),0,
                               lag(tot_plays))) %>% 
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_plays col, telling us how many plays occurred over period
      # standardizes it because play counts amongst teams vary a lot
      # if no games were played, they will return an NaN value
      # if some but not all games in the period were played, the 0's won't affect any calculations
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right') / 
                                rollapplyr(lag_plays, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>%  
      
      select(-c(tot_stat, tot_plays, lag_stat, lag_plays)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  off_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(off_df)))) {
    colnames(off_df)[i] = gsub(".*\\.", "", colnames(off_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    off_df = left_join(off_df, joining_df, by = c('pos_team', 'year', 'week'))
  }

  # rename pos_team so we can later merge with def stats
  off_df = off_df %>% 
    rename(team = pos_team)
  
  # add _off to cols for when we merge this to def
  colnames(off_df)[4:length(colnames(off_df))] = paste0(colnames(off_df)[4:length(colnames(off_df))], "_off_l", n_games)
  
  
  
  
  
  
  
  # Defensive metrics 
  
  
  
  # create list to store created defensive dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', i, "_pp")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(def_pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i)), # sum the stat
                tot_plays = sum(play_count)) %>% # sum the play count to calc per play later
      arrange(def_pos_team, year, week) %>% # sort by each level
      group_by(def_pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # if the previous row's plays is NA (haven't played a game yet), then make it 0 for the sum calc
      # now, we have the previous week's metric and plays
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_plays = ifelse(is.na(lag(tot_plays)),0,
                               lag(tot_plays))) %>% 
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_plays col, telling us how many plays occurred over period
      # standardizes it because play counts amongst teams vary a lot
      # if no games were played, they will return an NaN value
      # if some but not all games in the period were played, the 0's won't affect any calculations
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right') / 
                                rollapplyr(lag_plays, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>%
      
      select(-c(tot_stat, tot_plays, lag_stat, lag_plays)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  def_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(def_df)))) {
    colnames(def_df)[i] = gsub(".*\\.", "", colnames(def_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    def_df = left_join(def_df, joining_df, by = c('def_pos_team', 'year', 'week'))
  }
   
  # change def_pos_team for when we merge to off metrics
  def_df = def_df %>% 
    rename(team = def_pos_team)
  
  # add _def to cols so we differentiate from off metrics when merged
  colnames(def_df)[4:length(colnames(def_df))] = paste0(colnames(def_df)[4:length(colnames(def_df))], "_def_l", n_games)
  
  
  
  
  
  # Join Off and Def Metric dfs
  
  # left join
  full_df = left_join(off_df, def_df, by = c("team", "year", "week"))
  
  # rename game_id col, got messed up, and rename year to season for later merging
  colnames(full_df)[2] = "season"
  
  # return value is the one df with all rolling sums
  return(full_df)
  
}



```




## Rolling Grouped Per Play Function
```{r}
# Function to compile rolling metric variables per play at a lower grouped level
# meant for metrics that should be aggregated at per play level
# data can be grouped here (e.g. create a new df that filters for pass = 1, now this calculates pp stats on pass plays only, then do one for runs to get the flip side)


### FUNCTION ARGS EXPLAINED
# metrics: input list of desired metrics as they appear in cfb_data columns, e.g. c(EPA, wpa, ...)
# n_games: how many games for rolling sum to go back?, e.g. 5
# input_data: what data are we using (should always be cfb_data or filtered version), e.g. cfb_data
# group_abbrev: abbreviated name of the group for colnames, e.g. "rz" (to signify red zone plays only)



# Define function
rolling_gpp_compiler = function(metrics, n_games, input_data, group_abbrev){
  
  
  
  
  # Offensive Metrics
  
  
  
  # create list to store created dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', group_abbrev, "_", i, "_pp")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i)), # sum the stat
                tot_plays = sum(play_count)) %>% # sum the play count to calc per play later
      arrange(pos_team, year, week) %>% # sort by each level
      group_by(pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # if the previous row's plays is NA (haven't played a game yet), then make it 0 for the sum calc
      # now, we have the previous week's metric and plays
      
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_plays = ifelse(is.na(lag(tot_plays)),0,
                               lag(tot_plays))) %>% 
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_plays col, telling us how many plays occurred over period
      # standardizes it because play counts amongst teams vary a lot
      # if no games were played, they will return an NaN value
      # if some but not all games in the period were played, the 0's won't affect any calculations
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right') / 
                                rollapplyr(lag_plays, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>%  
      
      select(-c(tot_stat, tot_plays, lag_stat, lag_plays)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  off_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(off_df)))) {
    colnames(off_df)[i] = gsub(".*\\.", "", colnames(off_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    off_df = left_join(off_df, joining_df, by = c('pos_team', 'year', 'week'))
  }

  # rename pos_team so we can later merge with def stats
  off_df = off_df %>% 
    rename(team = pos_team)
  
  # add _off to cols for when we merge this to def
  colnames(off_df)[4:length(colnames(off_df))] = paste0(colnames(off_df)[4:length(colnames(off_df))], "_off_l", n_games)
  
  
  
  
  
  
  
  # Defensive metrics 
  
  
  
  # create list to store created defensive dfs
  df_list = c()

  # for loop for each off metric
  for (i in metrics) {
    # unique df and col names for each iteration
    new_df = paste0(i, '_df')
    new_name = paste0('rol_', group_abbrev, "_", i, "_pp")
  
    # create new df
    df = input_data %>% 
      filter(!is.na(!!sym(i))) %>% # take out NA rows for metric before summing
      group_by(def_pos_team, year, week) %>% # group by team/year/week 
      summarize(tot_stat = sum(!!sym(i)), # sum the stat
                tot_plays = sum(play_count)) %>% # sum the play count to calc per play later
      arrange(def_pos_team, year, week) %>% # sort by each level
      group_by(def_pos_team, year) %>% # define window of team and year
      
      # calculate lag of the stat (rolling function includes current row, need the lag)
      # if the previous row's metric is NA (haven't played a game yet), then make it 0 for the sum calc
      # if the previous row's plays is NA (haven't played a game yet), then make it 0 for the sum calc
      # now, we have the previous week's metric and plays
      mutate(lag_stat = ifelse(is.na(lag(tot_stat)),0,
                               lag(tot_stat)),
             lag_plays = ifelse(is.na(lag(tot_plays)),0,
                               lag(tot_plays))) %>%
      
      # use partial rollapplyr to calculate the right-aligned rolling sum of metric over last ___ games
      # then divide by the rolling sum of the lag_plays col, telling us how many plays occurred over period
      # standardizes it because play counts amongst teams vary a lot
      # if no games were played, they will return an NaN value
      # if some but not all games in the period were played, the 0's won't affect any calculations
      mutate(!!sym(new_name) := rollapplyr(lag_stat, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right') / 
                                rollapplyr(lag_plays, width = n_games, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>%
      
      select(-c(tot_stat, tot_plays, lag_stat, lag_plays)) # get rid of useless cols
  
    df_list[[paste0(i, '_df')]] <- df # add to df list
  

  }


  # select the first df from the list
  def_df = data.frame(df_list[1])
  # adjust cols to have same names as others (df list messed up)
  for (i in c(1:length(colnames(def_df)))) {
    colnames(def_df)[i] = gsub(".*\\.", "", colnames(def_df)[i])
  }
# loop to join dfs from list
  for (i in df_list[-1]) {
    # select df to join
    joining_df = i
    # adjust cols to have same names as others
    for (i in c(1:length(colnames(joining_df)))) {
      colnames(joining_df)[i] = gsub(".*\\.", "", colnames(joining_df)[i])
    }
    # join to one df
    def_df = left_join(def_df, joining_df, by = c('def_pos_team', 'year', 'week'))
  }
   
  # change def_pos_team for when we merge to off metrics
  def_df = def_df %>% 
    rename(team = def_pos_team)
  
  # add _def to cols so we differentiate from off metrics when merged
  colnames(def_df)[4:length(colnames(def_df))] = paste0(colnames(def_df)[4:length(colnames(def_df))], "_def_l", n_games)
  
  
  
  
  
  # Join Off and Def Metric dfs
  
  # left join
  full_df = left_join(off_df, def_df, by = c("team", "year", "week"))
  
  # rename game_id col, got messed up, and rename year to season for later merging
  colnames(full_df)[2] = "season"
  
  # return value is the one df with all rolling sums
  return(full_df)
  
}



```



## PbP Prep
```{r}

### FILTERED DATA ###


# data with no special teams plays
cfb_data_nonst = cfb_data %>% 
    filter(!kickoff_play & !punt_play &
           !str_detect(play_type, "Field Goal") &
           !play_type %in% c('End Period', 'End of Half', 'Timeout',
                             'End of 4th Quarter', 'End of Game')
           )

# data with runs only
cfb_data_run = cfb_data_nonst %>% filter(rush == 1)

# data with passes only
cfb_data_pass = cfb_data_nonst %>% filter(pass == 1)

# data with field goals only
cfb_data_fg = cfb_data %>% 
    filter(str_detect(play_type, "Field Goal")) %>% 
    mutate(fg_made = ifelse(fg_made == TRUE, 1, 0))
  






### 3-GAMES BACK STATS



# call desired per game metrics with rolling mean of 3 weeks
rolling_pg_orig_3 = rolling_pg_compiler(c("turnover", "touchdown", "sack", "punt", 
                                           "penalty_flag", "play_count"), 3, cfb_data)

# call desired per play metrics with rolling mean of 3 weeks
rolling_pp_orig_3 = rolling_pp_compiler(c("EPA", "wpa", "success", "pass"), 3, cfb_data_nonst)

# call desired per play metrics filtered for rush? with rolling mean of 3 weeks
rolling_run_orig_3 = rolling_gpp_compiler(c("EPA", "wpa", "success"), 3, cfb_data_run, "run")

# call desired per play metrics filtered for pass? with rolling mean of 3 weeks
rolling_pass_orig_3 = rolling_gpp_compiler(c("EPA", "wpa", "success"), 3, cfb_data_pass, "pass")








### LAST GAME STATS ###


# call desired per game metrics with rolling mean of 3 weeks
rolling_pg_orig_1 = rolling_pg_compiler(c("turnover", "touchdown", "sack", "punt",
                                           "penalty_flag", "play_count"), 1, cfb_data)

# call desired per play metrics with rolling mean of 3 weeks
rolling_pp_orig_1 = rolling_pp_compiler(c("EPA", "wpa", "success", "pass"), 1, cfb_data_nonst)

# call desired per play metrics filtered for rush? with rolling mean of 3 weeks
rolling_run_orig_1 = rolling_gpp_compiler(c("EPA", "wpa", "success"), 1, cfb_data_run, "run")

# call desired per play metrics filtered for pass? with rolling mean of 3 weeks
rolling_pass_orig_1 = rolling_gpp_compiler(c("EPA", "wpa", "success"), 1, cfb_data_pass, "pass")







### YEAR-LONG STATS ###

# call desired per game metrics with rolling mean of 3 weeks
rolling_pg_orig_yr = rolling_pg_compiler(c("turnover", "touchdown", "sack", "punt", 
                                           "penalty_flag", "play_count"), 20, cfb_data)

# call desired per play metrics with rolling mean of 3 weeks
rolling_pp_orig_yr = rolling_pp_compiler(c("EPA", "wpa", "success", "pass"), 20, cfb_data_nonst)

# call desired per play metrics filtered for rush? with rolling mean of 3 weeks
rolling_run_orig_yr = rolling_gpp_compiler(c("EPA", "wpa", "success"), 20, cfb_data_run, "run")

# call desired per play metrics filtered for pass? with rolling mean of 3 weeks
rolling_pass_orig_yr = rolling_gpp_compiler(c("EPA", "wpa", "success"), 20, cfb_data_pass, "pass")







### JOIN ALL PBP METRICS ###

# join all metrics
joined_metrics = left_join(rolling_pg_orig_3, rolling_pp_orig_3, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_run_orig_3, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pass_orig_3, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pg_orig_1, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pp_orig_1, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_run_orig_1, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pass_orig_1, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pg_orig_yr, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pp_orig_yr, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_run_orig_yr, by = c("team", "season", "week"))
joined_metrics = left_join(joined_metrics, rolling_pass_orig_yr, by = c("team", "season", "week"))




```

## Join Betting Data to GbG
```{r}

## JOIN BETTING DATA ##


# custom priority list for betting lines
provider_sort = c("consensus", "DraftKings", "ESPN Bet", "Caesars", "Caesars (Pennsylvania)", 
                  "Caesars Sportsbook (Colorado)", "William Hill (New Jersey)", #moved ESPN Bet up from here for 2025 on
                  "numberfire", "teamrankings", "Bovada", "SugarHouse")


# data frame for spread, pick one of the books' spread
full_df_sp = betting_lines %>% select(game_id, provider, spread) %>% rename(away_book_pd = spread) %>% filter(!is.na(away_book_pd))%>% group_by(game_id) %>% arrange(match(provider, provider_sort)) %>% slice(1) %>% ungroup()%>% select(-provider)

# data frame for over under, pick one of the books' over under
full_df_ou = betting_lines %>%  select(game_id, provider, over_under) %>% filter(!is.na(over_under)) %>%group_by(game_id) %>% arrange(match(provider, provider_sort)) %>% slice(1) %>% ungroup() %>% select(-provider)

# data frame for ml, pick one of the books' ml
full_df_ml = betting_lines %>%  select(game_id, provider, home_moneyline, away_moneyline) %>% filter(!is.na(home_moneyline)) %>%group_by(game_id) %>% arrange(match(provider, provider_sort)) %>% slice(1) %>% ungroup() %>% select(-provider)


# join the three data frames
game_info_bet = left_join(game_info, full_df_sp, by = c("game_id"))
game_info_bet = left_join(game_info_bet, full_df_ou, by = c("game_id"))
game_info_bet = left_join(game_info_bet, full_df_ml, by = c("game_id"))
```



## Join Talent Data to GbG
```{r}


## JOIN TALENT DATA ##


# change year
talent_data = talent_data_orig %>% 
  rename(season = year)


# home df
talent_data_home = talent_data %>% 
  rename(home_team = team,
         home_talent = talent)

# away df
talent_data_away = talent_data %>% 
  rename(away_team = team,
         away_talent = talent)



# join home and away dfs to GbG data respectively
game_info_talent = left_join(game_info_bet, talent_data_home, c("season", "home_team"))
game_info_talent = left_join(game_info_talent, talent_data_away, c("season", "away_team"))

```

## Join Ranking Data to GbG
```{r}

## JOIN RANKING DATA ##



# last week of regular season for each year? to determine which week will be joined to postseason 
max_weeks  = ranking_data_orig %>% group_by(season) %>% summarise(max_week = max(week))



# join ranking data with max weeks
ranking_data = left_join(ranking_data_orig, max_weeks, c("season")) %>% 
  filter(poll == "AP Top 25", # just regular season AP
         season_type == "regular") %>% 
  mutate(week = week + 1) %>% # weeks correspond with the next, change
  mutate(season_type = ifelse((week > max_week & season != current_season) | (week > max_week & season == current_season & current_week > 19), "postseason", "regular")) %>% # for past seasons, the last week will correspond to postseason, for this season, it will only do so if we are currently in the postseason
  mutate(rank_tier = ifelse(rank >= 17, 3, ifelse(rank >= 9, 2, ifelse(rank >= 1, 1)))) %>% # tiers of rankings from 1-4 (1-8, 9-16, 17-25, unranked)
  select(school, week, season, rank_tier, season_type)


# regular season df
ranking_data_reg = ranking_data %>% 
  filter(season_type == "regular") %>% 
  select(-season_type)

# home
ranking_data_reg_home = ranking_data_reg %>% 
  rename(rank_tier_home = rank_tier,
         home_team = school) 
# away
ranking_data_reg_away = ranking_data_reg %>% 
  rename(rank_tier_away = rank_tier,
         away_team = school)
  


# postseason df
ranking_data_post = ranking_data %>% 
  filter(season_type == "postseason") %>% 
  select(-week)

# home
ranking_data_post_home = ranking_data_post %>% 
  rename(rank_tier_home_post = rank_tier,
         home_team = school)
# away
ranking_data_post_away = ranking_data_post %>% 
  rename(rank_tier_away_post = rank_tier,
         away_team = school)




# join regular/postseason home/away dfs respectively to GbG
game_info_rank = left_join(game_info_talent, ranking_data_reg_home, by = c("home_team", "season", "week"))
game_info_rank = left_join(game_info_rank, ranking_data_post_home, by = c("home_team", "season", "season_type"))
game_info_rank = left_join(game_info_rank, ranking_data_reg_away, by = c("away_team", "season", "week"))
game_info_rank = left_join(game_info_rank, ranking_data_post_away, by = c("away_team", "season", "season_type"))


# if a given week is in the postseason, make that the team's rank tier
# if a given team is unranked (NA for joined value), they are tier 4
game_info_rank = game_info_rank %>% 
  mutate(rank_tier_away = ifelse(!is.na(rank_tier_away_post), rank_tier_away_post, rank_tier_away),
         rank_tier_home = ifelse(!is.na(rank_tier_home_post), rank_tier_home_post, rank_tier_home)) %>% 
  select(-c(rank_tier_away_post, rank_tier_home_post)) %>% 
  mutate(rank_tier_away = ifelse(!is.na(rank_tier_away), rank_tier_away, 4)) %>% 
  mutate(rank_tier_home = ifelse(!is.na(rank_tier_home), rank_tier_home, 4))



```



## Join Weather Data to GbG
```{r}


## JOIN WEATHER DATA ##

# 
# # select necessary cols, change if indoor, create categories for rain (for easier future predictions)
# weather_data = weather_data_orig %>% 
#   select(game_id, game_indoors, temperature, humidity, precipitation, wind_speed) %>% 
#   mutate(temperature = ifelse(game_indoors, 70, temperature)) %>% 
#   mutate(humidity = ifelse(game_indoors, 30, humidity)) %>% 
#   mutate(precipitation = ifelse(game_indoors, 0, precipitation)) %>% 
#   mutate(wind_speed = ifelse(game_indoors, 0, wind_speed)) %>% 
#   mutate(precipitation_code = ifelse(precipitation > .035, "heavy_rain", ifelse(
#                                      precipitation > .01, "moderate_rain", ifelse(
#                                      precipitation > .00, "light_rain", "no_rain"
#                                      )))) %>% 
#   select(-c(precipitation, game_indoors))
# 
# 
# # join data to GbG
# game_info_weather = left_join(game_info_rank, weather_data, by = "game_id")



```



## GbG Prep
```{r}



### SELECT IMPORTANT COLS AND MAKE NEW ONES


# select important columns from game_info and create needed cols
game_data = game_info_rank %>%
  mutate(temperature = 0, humidity = 0, wind_speed = 0)
game_data$precipitation_code = rep(c("heavy_rain", "moderate_rain", "light_rain", "no_rain"),length.out = dim(game_data)[1])
game_data = game_data %>% 
  select(game_id, season, week, season_type, completed, neutral_site, conference_game, home_team,
         home_conference, home_division, home_points, home_moneyline, home_talent, rank_tier_home,
         home_pregame_elo, away_team, away_conference, away_division, away_points, away_book_pd,
         away_moneyline, away_talent, rank_tier_away, away_pregame_elo, over_under, temperature, 
         humidity, wind_speed, precipitation_code) %>% 
  mutate(total_points = home_points + away_points, # eventual response var
         home_point_diff = home_points - away_points,# eventual response var
         away_point_diff = away_points - home_points, # eventual response var
         home_win = ifelse(home_points > away_points, 1, 0), # eventual response var and predictor
         away_win = ifelse(away_points > home_points, 1, 0)) # eventual response var and predictor








### CREATE HOME DF AND MAKE HOME/AWAY STATS



# just make home teams t1
home_df = game_data %>% 
  rename(t1_team = home_team,
         t1_conference = home_conference,
         t1_division = home_division,
         t1_points = home_points,
         t1_point_diff = home_point_diff,
         t1_win = home_win,
         t1_moneyline = home_moneyline,
         t1_talent = home_talent,
         t1_rank_tier = rank_tier_home,
         t1_elo = home_pregame_elo,
         t1_book_spread = away_book_pd,
         t2_team = away_team,
         t2_conference = away_conference,
         t2_division = away_division,
         t2_points = away_points,
         t2_point_diff = away_point_diff,
         t2_win = away_win,
         t2_moneyline = away_moneyline,
         t2_talent = away_talent,
         t2_rank_tier = rank_tier_away,
         t2_elo = away_pregame_elo,
         book_over_under = over_under) %>% 
  mutate(t1_home = 1,
         t2_home = 0,
         t1_serv_acad = ifelse(t1_team %in% c("Army", "Navy", "Air Force"), 1, 0),
         t2_serv_acad = ifelse(t2_team %in% c("Army", "Navy", "Air Force"), 1, 0)) %>% 
  mutate(t1_talent = ifelse(t1_serv_acad == 1, 0, t1_talent),
         t2_talent = ifelse(t2_serv_acad == 1, 0, t2_talent)) %>% 
  
  
  # create home/away stats
  arrange(t1_team, season, week) %>% # sort before lag calc
  group_by(t1_team, season) %>% # group before lag calc
  
  # create lag win and loss stat cols for team 1, returning 0 if they didn't play a game yet
  mutate(lag_win = ifelse(is.na(lag(t1_win)), 0, lag(t1_win)),
         lag_loss = ifelse(is.na(lag(t2_win)), 0, lag(t2_win))) %>% 
  
  # calculate rolling totals of home/away wins and losses for the last 3 games and all season for 
  mutate(rol_win_ha_l20 := rollapplyr(lag_win, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_loss_ha_l20 := rollapplyr(lag_loss, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>% 
  
  # calculate records over these periods to standardize
  mutate(t1_rol_record_ha_l20 = rol_win_ha_l20 / (rol_win_ha_l20 + rol_loss_ha_l20)) %>% 
  
  # calculate lag points and points against stat cols for t1, returning 0 if they didn't play yet
  # also create lag_game, signifying if a team has played a game yet
  mutate(lag_pf = ifelse(is.na(lag(t1_points)), 0, lag(t1_points)),
         lag_pa = ifelse(is.na(lag(t2_points)), 0, lag(t2_points)),
         lag_game = ifelse(is.na(lag(t1_points)), 0, 1)) %>% 
  
  # divide rolling points/pa by games to get standardized h/a points/pa metric over last 3 games and season
  mutate(t1_rol_pf_pg_ha_l20 :=  rollapplyr(lag_pf, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pa_pg_ha_l20 := rollapplyr(lag_pa, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right')) %>% 
  
  select(-c(lag_win, lag_loss, rol_win_ha_l20, rol_loss_ha_l20, lag_pf, 
            lag_pa, lag_game)) %>% 
  
  
  
  arrange(t2_team, season, week) %>% # sort before lag calc
  group_by(t2_team, season) %>% # group before lag calc
  
  # create lag win and loss stat cols for team 1, returning 0 if they didn't play a game yet
  mutate(lag_win = ifelse(is.na(lag(t2_win)), 0, lag(t2_win)),
         lag_loss = ifelse(is.na(lag(t1_win)), 0, lag(t1_win))) %>% 
  
  # calculate rolling totals of home/away wins and losses for the last 3 games and all season
  mutate(rol_win_ha_l20 := rollapplyr(lag_win, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_loss_ha_l20 := rollapplyr(lag_loss, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>% 
  
  # calculate records over these periods to standardize
  mutate(t2_rol_record_ha_l20 = rol_win_ha_l20 / (rol_win_ha_l20 + rol_loss_ha_l20)) %>% 
  
  # calculate lag points and points against stat cols for t1, returning 0 if they didn't play yet
  # also create lag_game, signifying if a team has played a game yet
  mutate(lag_pf = ifelse(is.na(lag(t2_points)), 0, lag(t2_points)),
         lag_pa = ifelse(is.na(lag(t1_points)), 0, lag(t1_points)),
         lag_game = ifelse(is.na(lag(t2_points)), 0, 1)) %>% 
  
  # divide rolling points/pa by games to get standardized h/a points/pa metric over last 3 games and season
  mutate(t2_rol_pf_pg_ha_l20 :=  rollapplyr(lag_pf, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t2_rol_pa_pg_ha_l20 := rollapplyr(lag_pa, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right')) %>% 
  
  select(-c(lag_win, lag_loss, rol_win_ha_l20, rol_loss_ha_l20, lag_pf, 
            lag_pa, lag_game))
  
  
  





### CREATE AWAY DF ###



# just make away teams t1
away_df = home_df %>% 
  rename(t2_team = t1_team,
         t2_conference = t1_conference,
         t2_division = t1_division,
         t2_points = t1_points,
         t2_point_diff = t1_point_diff,
         t2_win = t1_win,
         t2_moneyline = t1_moneyline,
         t2_talent = t1_talent,
         t2_rank_tier = t1_rank_tier,
         t2_elo = t1_elo,
         t2_serv_acad = t1_serv_acad,
         t1_team = t2_team,
         t1_conference = t2_conference,
         t1_division = t2_division,
         t1_points = t2_points,
         t1_point_diff = t2_point_diff,
         t1_win = t2_win,
         t1_moneyline = t2_moneyline,
         t1_talent = t2_talent,
         t1_rank_tier = t2_rank_tier,
         t1_elo = t2_elo,
         t1_serv_acad = t2_serv_acad,
         t1_rol_record_ha_l20 = t2_rol_record_ha_l20,
         t1_rol_pf_pg_ha_l20 = t2_rol_pf_pg_ha_l20,
         t1_rol_pa_pg_ha_l20 = t2_rol_pa_pg_ha_l20,
         t2_rol_record_ha_l20 = t1_rol_record_ha_l20,
         t2_rol_pf_pg_ha_l20 = t1_rol_pf_pg_ha_l20,
         t2_rol_pa_pg_ha_l20 = t1_rol_pa_pg_ha_l20) %>% 
  mutate(t1_home = 0,
         t2_home = 1,
         t1_book_spread = t1_book_spread * -1) 








  ### BIND HOME AND AWAY DFS AND CREATE OVERALL GBG METRICS ###


# bind home and away dfs and create rolling predictors from them
t1_game_info_metrics= rbind(home_df, away_df) %>% 
  select(-t2_point_diff) %>% # don't need anymore
  arrange(t1_team, season, week) %>% # sort before lag calc
  group_by(t1_team, season) %>% # group before lag calc
  
  # create lag win and loss stat cols for team 1, returning 0 if they didn't play a game yet
  mutate(lag_win = ifelse(is.na(lag(t1_win)), 0, lag(t1_win)),
         lag_loss = ifelse(is.na(lag(t2_win)), 0, lag(t2_win))) %>% 
  
  # calculate rolling totals of wins and losses for the last 3 games and all season
  mutate(rol_win_l3 := rollapplyr(lag_win, width = 3, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_loss_l3 := rollapplyr(lag_loss, width = 3, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_win_l1 := rollapplyr(lag_win, width = 1, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_loss_l1 := rollapplyr(lag_loss, width = 1, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_win_l20 := rollapplyr(lag_win, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right'),
         rol_loss_l20 := rollapplyr(lag_loss, width = 20, FUN = sum, 
                                           partial = TRUE, align = 'right')) %>% 
  
  # calculate records over these periods to standardize
  mutate(t1_rol_record_l3 = rol_win_l3 / (rol_win_l3 + rol_loss_l3),
         t1_rol_record_l1 = rol_win_l1 / (rol_win_l1 + rol_loss_l1),
         t1_rol_record_l20 = rol_win_l20 / (rol_win_l20 + rol_loss_l20)) %>% 
  
  # calculate lag points and points against stat cols for t1, returning 0 if they didn't play yet
  # also create lag_game, signifying if a team has played a game yet
  mutate(lag_pf = ifelse(is.na(lag(t1_points)), 0, lag(t1_points)),
         lag_pa = ifelse(is.na(lag(t2_points)), 0, lag(t2_points)),
         lag_game = ifelse(is.na(lag(t1_points)), 0, 1)) %>% 
  
  # divide rolling points/pa by games to get standardized points/pa metric over last 3 games and season
  mutate(t1_rol_pf_pg_l3 :=  rollapplyr(lag_pf, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pa_pg_l3 := rollapplyr(lag_pa, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pf_pg_l1 :=  rollapplyr(lag_pf, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pa_pg_l1 := rollapplyr(lag_pa, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pf_pg_l20 :=  rollapplyr(lag_pf, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_pa_pg_l20 := rollapplyr(lag_pa, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right')) %>% 
  
  select(-c(lag_win, lag_loss, rol_win_l3, rol_loss_l3, rol_win_l20, rol_loss_l20, lag_pf, 
            lag_pa, lag_game, t2_win)) %>% 
  
  
  
  
  
  
  # create SoS rolling avgs
  mutate(lag_opp_rk = ifelse(is.na(lag(t2_rank_tier)), 0, lag(t2_rank_tier)),
         lag_opp_elo = ifelse(is.na(lag(t2_elo)), 0, lag(t2_elo)),
         lag_opp_talent = ifelse(is.na(lag(t2_talent)), 0, lag(t2_talent)),
         lag_game_rk = ifelse(is.na(lag(t2_rank_tier)), 0, 1),
         lag_game_elo = ifelse(is.na(lag(t2_elo)), 0, 1),
         lag_game_talent = ifelse(is.na(lag(t2_talent)), 0, 1)) %>% 
  
  
  # 
  mutate(t1_rol_opp_rk_l3 :=  rollapplyr(lag_opp_rk, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_rk, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_elo_l3 :=  rollapplyr(lag_opp_elo, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_elo, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_talent_l3 :=  rollapplyr(lag_opp_talent, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_talent, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_rk_l1 :=  rollapplyr(lag_opp_rk, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_rk, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_elo_l1 :=  rollapplyr(lag_opp_elo, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_elo, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_talent_l1 :=  rollapplyr(lag_opp_talent, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_talent, width = 1, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_rk_l20 :=  rollapplyr(lag_opp_rk, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_rk, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_elo_l20 :=  rollapplyr(lag_opp_elo, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_elo, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_opp_talent_l20 :=  rollapplyr(lag_opp_talent, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_talent, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right')) %>% 
  
  select(-c(lag_opp_rk, lag_opp_elo, lag_opp_talent, lag_game_rk, lag_game_talent, lag_game_elo)) %>% 
  
  

  
  ## create roll avg book errors
  mutate(actual_spread = t2_points - t1_points,
         actual_over_under = (t1_points + t2_points)) %>% 
  mutate(book_spread_error = t1_book_spread - actual_spread,
         book_over_under_error = book_over_under - actual_over_under) %>% 
  mutate(lag_spread_err = ifelse(is.na(lag(book_spread_error)), 0, lag(book_spread_error)),
         lag_ou_error = ifelse(is.na(lag(book_over_under_error)), 0, lag(book_over_under_error)),
         lag_game_spread = ifelse(is.na(lag(book_spread_error)), 0, 1),
         lag_game_ou = ifelse(is.na(lag(book_over_under_error)), 0, 1)) %>% 
  mutate(t1_rol_spr_err_l3 :=  rollapplyr(lag_spread_err, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_spread, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_ou_err_l3 :=  rollapplyr(lag_ou_error, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_ou, width = 3, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_spr_err_l20 :=  rollapplyr(lag_spread_err, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_spread, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'),
         t1_rol_ou_err_l20 :=  rollapplyr(lag_ou_error, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right') /
                        rollapplyr(lag_game_ou, width = 20, FUN = sum, # right rolling sum using lag
                                           partial = TRUE, align = 'right'))%>% 
  
  select(-c(actual_spread, actual_over_under, book_spread_error, book_over_under_error, lag_spread_err, lag_ou_error, lag_game_spread, lag_game_ou))
  










### CHANGE INTO T1 AND T2 DF ###


# create df that changes t1 metrics into t2 metrics
t2_game_info_metrics = t1_game_info_metrics %>% 
  select(season, week, t1_team, t1_rol_record_l3, t1_rol_record_l1, t1_rol_record_l20, t1_rol_pa_pg_l3,
         t1_rol_pa_pg_l1, t1_rol_pa_pg_l20, t1_rol_pf_pg_l3, t1_rol_pf_pg_l1, t1_rol_pf_pg_l20,
         t1_rol_opp_rk_l3, t1_rol_opp_rk_l1, t1_rol_opp_rk_l20, t1_rol_opp_elo_l3, t1_rol_opp_elo_l1,
         t1_rol_opp_elo_l20, t1_rol_opp_talent_l3, t1_rol_opp_talent_l1, t1_rol_opp_talent_l20,
         t1_rol_spr_err_l3, t1_rol_ou_err_l3, t1_rol_spr_err_l20, t1_rol_ou_err_l20) %>% 
  rename(t2_team = t1_team, 
         t2_rol_record_l3 = t1_rol_record_l3, 
         t2_rol_record_l1 = t1_rol_record_l1,
         t2_rol_record_l20 = t1_rol_record_l20, 
         t2_rol_pa_pg_l3 = t1_rol_pa_pg_l3,
         t2_rol_pa_pg_l1 = t1_rol_pa_pg_l1,
         t2_rol_pa_pg_l20 = t1_rol_pa_pg_l20, 
         t2_rol_pf_pg_l3 = t1_rol_pf_pg_l3, 
         t2_rol_pf_pg_l1 = t1_rol_pf_pg_l1,
         t2_rol_pf_pg_l20 = t1_rol_pf_pg_l20,
         
         t2_rol_opp_rk_l3 = t1_rol_opp_rk_l3,
         t2_rol_opp_rk_l1 = t1_rol_opp_rk_l1,
         t2_rol_opp_rk_l20 = t1_rol_opp_rk_l20,
         t2_rol_opp_elo_l3 = t1_rol_opp_elo_l3,
         t2_rol_opp_elo_l1 = t1_rol_opp_elo_l1,
         t2_rol_opp_elo_l20 = t1_rol_opp_elo_l20,
         t2_rol_opp_talent_l3 = t1_rol_opp_talent_l3,
         t2_rol_opp_talent_l1 = t1_rol_opp_talent_l1,
         t2_rol_opp_talent_l20 = t1_rol_opp_talent_l20,
         
         t2_rol_spr_err_l3 = t1_rol_spr_err_l3,
         t2_rol_ou_err_l3 = t1_rol_ou_err_l3,
         t2_rol_spr_err_l20 = t1_rol_spr_err_l20,
         t2_rol_ou_err_l20 = t1_rol_ou_err_l20) 




# join those t2 metrics to the t1 df (because teams appear on both sides each week)
all_df = left_join(t1_game_info_metrics, t2_game_info_metrics, by = c('t2_team', 'week', 'season')) %>% 
    mutate(t1_home = ifelse(neutral_site, 0, t1_home),
         t2_home = ifelse(neutral_site, 0, t2_home),
         neutral_site = ifelse(neutral_site, 1, 0)) %>% 
  mutate(t1_rol_record_ha_l20 = ifelse(neutral_site == 1, t1_rol_record_l20, t1_rol_record_ha_l20),
         t1_rol_pf_pg_ha_l20 = ifelse(neutral_site == 1, t1_rol_pf_pg_l20, t1_rol_pf_pg_ha_l20),
         t1_rol_pa_pg_ha_l20 = ifelse(neutral_site == 1, t1_rol_pa_pg_l20, t1_rol_pa_pg_ha_l20),
         t2_rol_record_ha_l20 = ifelse(neutral_site == 1, t2_rol_record_l20, t2_rol_record_ha_l20),
         t2_rol_pf_pg_ha_l20 = ifelse(neutral_site == 1, t2_rol_pf_pg_l20, t2_rol_pf_pg_ha_l20),
         t2_rol_pa_pg_ha_l20 = ifelse(neutral_site == 1, t2_rol_pa_pg_l20, t2_rol_pa_pg_ha_l20)
         ) %>% 
  mutate(regular_szn = ifelse(season_type == "regular", 1, 0)) %>% 
  select(-season_type)

  
```


## Join PbP and GbG data
```{r}


### JOIN PBP AND GBG DATA



# prep the pbp metrics for joining by t1
t1_prepped_metrics = joined_metrics %>% 
  rename(t1_team = team)
colnames(t1_prepped_metrics)[4:length(colnames(t1_prepped_metrics))] = 
  paste("t1_", colnames(t1_prepped_metrics)[4:length(colnames(t1_prepped_metrics))])

# prep the pbp metrics for joining by t2
t2_prepped_metrics = joined_metrics %>% 
  rename(t2_team = team)
colnames(t2_prepped_metrics)[4:length(colnames(t2_prepped_metrics))] = 
  paste("t2_", colnames(t2_prepped_metrics)[4:length(colnames(t2_prepped_metrics))])



# join t1 pbp metrics to all_df
t1_joined = left_join(all_df, t1_prepped_metrics, by = c("t1_team", "season", "week"))

# join t2 pbp metrics to t1_joined
both_joined = left_join(t1_joined, t2_prepped_metrics, by = c("t2_team", "season", "week"))

```



## Join in Stats Data
```{r}

### Join the Joined df with stats api


# 
# 
# stat_year_range = unique(range(stat_data$season))
# 
# 
# for (yr in stat_year_range){
#   
#   if (yr == unique(range(stat_data$season))[1]){
#   
#       stat_data_filt = stat_data %>% filter(season == yr)
#       unique_teams = unique(stat_data_filt$team)
#       unique_weeks = unique(stat_data_filt$join_wk)
#       
#       stat_data_all = data.frame(expand.grid(team = unique_teams, join_wk = unique_weeks, season = yr))
#   
#   } else{
#     
#       stat_data_filt = stat_data %>% filter(season == yr)
#       unique_teams = unique(stat_data_filt$team)
#       unique_weeks = unique(stat_data_filt$join_wk)   
#       
#       stat_data_yr = data.frame(expand.grid(team = unique_teams, join_wk = unique_weeks, season = yr))
#       
#       stat_data_all = bind_rows(stat_data_yr, stat_data_all)
#     
#   }
#   
# }
# 
# 
# stat_data_joined = left_join(stat_data_all, stat_data, by = c("team", "season", "join_wk")) %>% 
#   arrange(team, season, join_wk) %>% 
#   group_by(team, season) %>% 
#   mutate(across(everything(), ~ ifelse(
#     is.na(.), 
#     ifelse(!is.na(lag(.)), lag(.), lag(., 2)),  # Check lag 1, then lag 2
#     .
#   ))) %>% 
#   ungroup()
# 
# 
# 
# 
# 
# 
# 
# 
# both_joined_mut = left_join(both_joined, weeks_in_seasons, by = "season")
# 
# both_joined_mut = both_joined_mut %>% 
#   mutate(join_wk = ifelse(week < 19, week, max_week + 1))
# 
# 
# 
# 
# stat_data_t1 = stat_data_joined %>% 
#   rename(t1_team = team)
# 
# colnames(stat_data_t1) <- ifelse(
#   grepl("off", colnames(stat_data_t1)),  # Check if column name contains "off"
#   paste0("t1_", colnames(stat_data_t1)),
#   ifelse(
#     grepl("def", colnames(stat_data_t1)),  # Check if column name contains "def"
#     paste0("t1_", colnames(stat_data_t1)),
#     colnames(stat_data_t1)  # Leave other column names unchanged
#   )
# )
# 
# 
# 
# 
# stat_data_t2 = stat_data_joined%>% 
#   rename(t2_team = team)
# 
# colnames(stat_data_t2) <- ifelse(
#   grepl("off", colnames(stat_data_t2)),  # Check if column name contains "off"
#   paste0("t2_", colnames(stat_data_t2)),
#   ifelse(
#     grepl("def", colnames(stat_data_t2)),  # Check if column name contains "def"
#     paste0("t2_", colnames(stat_data_t2)),
#     colnames(stat_data_t2)  # Leave other column names unchanged
#   )
# )
# 
# 
# 
# 
# stat_joined = left_join(both_joined_mut, stat_data_t1, by = c("t1_team", "season", "join_wk"))
# stat_joined = left_join(stat_joined, stat_data_t2, by = c("t2_team", "season", "join_wk")) %>% 
#   select(-c(max_week, join_wk))


```





## Create Over Average Metrics
```{r}


### CREATE NEEDED FUNCTIONS ###


# func to see what rolling window we're looking at
get_window_size <- function(column_name) {
  ifelse(substr(column_name, nchar(column_name) - 5, nchar(column_name) - 5) == "l",
         as.numeric(substr(column_name, nchar(column_name) - 4, nchar(column_name) - 4)),
         as.numeric(substr(column_name, nchar(column_name) - 5, nchar(column_name) - 4)))
}


# func to get matching rollavg cols to compute calcs for the off/def cols
get_matching_col_offdef <- function(colname, swap_team, swap_role, swap_window) {
  if(swap_window == TRUE){
    new1 = gsub("(t[12])", swap_team, colname)
    new2 = gsub("l1", "l3", new1)
    gsub("(off|def)", swap_role, new2)
    } else {
    new1 = gsub("(t[12])", swap_team, colname)
    gsub("(off|def)", swap_role, new1)}
}

# func to get matching rollavg cols to compute calcs for the pf/pa cols
get_matching_col_pfpa <- function(colname, swap_team, swap_role, swap_window) {
  if(swap_window == TRUE){
    new1 = gsub("(t[12])", swap_team, colname)
    new2 = gsub("l1", "l3", new1)
    gsub("(pf|pa)", swap_role, new2)
    } else {
    new1 = gsub("(t[12])", swap_team, colname)
    gsub("(pf|pa)", swap_role, new1)}
}

# func to get matching rollavg cols to compute calcs for the record cols
get_matching_col_record <- function(colname, swap_team, swap_window) {
  if(swap_window == TRUE){
    new1 = gsub("(t[12])", swap_team, colname)
    gsub("l1", "l3", new1)
    } else {
    gsub("(t[12])", swap_team, colname)}
}



#both_joined = both_joined %>% filter(season == 2024)



### PBP METRICS OA CALCS ###



# pbp stats 
pbp_oa = both_joined %>% 
  
  ## T1
  
  # group by
  arrange(t1_team, season, week) %>% 
  group_by(t1_team, season) %>% 
  
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(off|def)") & matches("t2") & !matches("_total_ppa_"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(off|def).*lag"), # select columns with "off"/"def" and "t1"/"t2"
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # dalculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling average
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg"
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"),
    .cols = ends_with("_lag_rollavg") # select roll avg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(off|def)") & matches("t1") & !matches("_rollavg")  & !matches("_total_ppa_"), # Select original columns
    .fns = ~ {
      # identify the current team (t1/t2) and role (off/def)
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_role <- ifelse(grepl("off", current_col), "def", "off")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching col name
      matching_col <- get_matching_col_offdef(current_col, new_team, new_role, new_window)
      
      # subtract w matching col
      
      result = . - get(paste0(matching_col, "_rollavg"))
      return(result)
      } 
    ,
    .names = "{.col}_oa" # Add differences as new columns
  )) %>%
  
  select(-contains("rollavg")) %>% 
  ungroup() %>% 
  
  
  ## T2
  
  # group by
  arrange(t2_team, season, week) %>% 
  group_by(t2_team, season) %>% 
  
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(off|def)") & matches("t1") & !matches("oa") & !matches("_total_ppa_"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(off|def).*lag"), # Select columns containing "off"/"def" and "t1"/"t2"
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # calculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling average
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg" 
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"), 
    .cols = ends_with("_lag_rollavg") # select rollavg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(off|def)") & matches("t2") & !matches("_rollavg")  & !matches("_total_ppa_"),
    .fns = ~ {
      # identify the current team (t1/t2) and role (off/def)
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_role <- ifelse(grepl("off", current_col), "def", "off")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching col name
      matching_col <- get_matching_col_offdef(current_col, new_team, new_role, new_window)
      
      # subtract w matching col
      
      result = . - get(paste0(matching_col, "_rollavg"))
      return(result)
      } 
    ,
    .names = "{.col}_oa" 
  )) %>%
  
  select(-contains("rollavg")) %>% 
  ungroup() 
  
  
  
  










### GBG POINTS METRICS OA CALCS ###

# gbg points stats
points_oa = pbp_oa %>% 
  
  ## T1
  
  # group by
  arrange(t1_team, season, week) %>% 
  group_by(t1_team, season) %>% 
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(_pf_|_pa_)") & matches("t2"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(_pf_|_pa_).*lag"), # Select columns 
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # calculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling average
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg"
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"),
    .cols = ends_with("_lag_rollavg") # select rollavg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(_pf_|_pa_)") & matches("t1") & !matches("_rollavg"), # Select original columns
    .fns = ~ {
      # Identify 
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_role <- ifelse(grepl("pf", current_col), "pa", "pf")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching column name
      matching_col <- get_matching_col_pfpa(current_col, new_team, new_role, new_window)
      
      # subtract w matching col
      
      result = . - get(paste0(matching_col, "_rollavg"))
      return(result)
      } 
    ,
    .names = "{.col}_oa" 
  )) %>% 
  
  select(-contains("rollavg")) %>% 
  ungroup() %>% 
  
  
  ## T2

  arrange(t2_team, season, week) %>% 
  group_by(t2_team, season) %>% 
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(_pf_|_pa_)") & matches("t1") & !matches("oa"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(_pf_|_pa_).*lag"), # Select columns 
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # calculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg" 
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"), 
    .cols = ends_with("_lag_rollavg") # select rollavg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(_pf_|_pa_)") & matches("t2") & !matches("_rollavg") , # Select original columns
    .fns = ~ {
      # identify current col
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_role <- ifelse(grepl("pf", current_col), "pa", "pf")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching column name
      matching_col <- get_matching_col_pfpa(current_col, new_team, new_role, new_window)
      
      # subtract w original col
      
      result = . - get(paste0(matching_col, "_rollavg"))
      return(result)
      } 
    ,
    .names = "{.col}_oa"
  )) %>% 
  
  select(-contains("rollavg")) %>% 
  ungroup()  









### GBG RECORD METRICS OA CALCS ###


# gbg record stats
all_oa = points_oa %>%
  
  ## T1
  
  # group by
  arrange(t1_team, season, week) %>% 
  group_by(t1_team, season) %>% 
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(record)") & matches("t2"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(record).*lag"), # Select columns 
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # calculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling average
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg" # Add rolling averages as new columns
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"),
    .cols = ends_with("_lag_rollavg") # select rollavg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(record)") & matches("t1") & !matches("_rollavg") , # Select original columns
    .fns = ~ {
      # identify the current team (t1/t2) and role (off/def)
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching column name
      matching_col <- get_matching_col_record(current_col, new_team, new_window)
      
      # subtract w original col
      
      result = . - (1-get(paste0(matching_col, "_rollavg")))
      return(result)
      } 
    ,
    .names = "{.col}_oa"
  )) %>% 
  
  select(-contains("rollavg"))%>% 
  ungroup() %>% 
  
  
  ## T2
  
  # group by
  arrange(t2_team, season, week) %>% 
  group_by(t2_team, season) %>% 
  
  # compute lags for all stats
  mutate(across(
    .cols = matches("(record)") & matches("t1") & !matches("oa"),
    .fns = ~ {
      lag(.x, n = 1)
    },
    .names = "{.col}_lag"
  )) %>% 
  
  # compute rolling means based on these lags
  mutate(across(
    .cols = matches("(record).*lag"), # Select columns 
    .fns = ~ {
      # determine the rolling window size based on the column name
      window_size <- get_window_size(cur_column())
      
      # calculate the rolling sum
      rolling_sum <- rollapplyr(replace(.x, is.na(.x), 0), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling count (number of rows used)
      rolling_count <- rollapplyr(!is.na(.x), width = window_size, FUN = sum, partial = TRUE, align = "right")
      
      # calculate the rolling average
      rolling_sum / rolling_count
    },
    .names = "{.col}_rollavg"
  )) %>%
  rename_with(
    .fn = ~ str_replace(., "_lag_rollavg$", "_rollavg"),
    .cols = ends_with("_lag_rollavg") # select rollavg cols
  ) %>% 
  select(-contains("lag")) %>% 
  
    
  # for each original column, find its rolling average inverse and compute the oa stat
  mutate(across(
    .cols = matches("(record)") & matches("t2") & !matches("_rollavg") , # Select original columns
    .fns = ~ {
      # identify the current team (t1/t2) and role (off/def)
      current_col <- cur_column()
      new_team <- ifelse(grepl("t1", current_col), "t2", "t1")
      new_window = ifelse(grepl("l1", current_col), TRUE, FALSE)
      
      # construct the matching column name
      matching_col <- get_matching_col_record(current_col, new_team, new_window)
      
      # subtract w original col
      
      result = . - (1-get(paste0(matching_col, "_rollavg")))
      return(result)
      } 
    ,
    .names = "{.col}_oa"
  )) %>% 
  
  select(-contains("rollavg"))%>% 
  ungroup() 



  
```


## Over Time Difference Stats
```{r}



## DIFFERENCE OVER TIME STAT CALCS ##


# func to get matching rollavg cols to compute calcs for the off/def cols
get_matching_col_otdiff3 <- function(colname, window) {
    gsub("l3", window, colname)
}



# compute stats for l3 vs l20
ot_diff = all_oa %>% 
  # for each original column, find the difference between recent and past of the stat
  mutate(across(
    .cols = matches("l3") & !matches("_err_"), 
    .fns = ~ {
      # identify col 
      current_col <- cur_column()
      new_window = "l20"
      
      # construct the matching column name
      matching_col <- get_matching_col_otdiff3(current_col, new_window)
      
      # Perform the subtraction if the matching column exists
      
      result = . - get(matching_col)
      return(result)
      } 
    ,
    .names = "{.col}_diffl20" # new cols
  )) 



```




Write Master df to csv
```{r}

# final df
final_df = ot_diff 

write.csv(final_df, "current_data/this_week_prepped_data.csv")



```




